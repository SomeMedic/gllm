#!/usr/bin/env node
import { Command } from "commander";
import * as fs from "fs";
import * as path from "path";
import { run, safeName, guessLangByExt } from "./utils";

const pkg: any = require("../package.json");

type Options = {
  out: string;
  branches: string;
  commitsPerBranch: number;
  maxFileSize: number;
  includeFiles: boolean;
  exclude: string;
  secretScan: boolean;
};

function writeFile(target: string, content: string) {
  fs.mkdirSync(path.dirname(target), { recursive: true });
  fs.writeFileSync(target, content, { encoding: "utf-8" });
}

function gitTopLevel(): string {
  return run("git rev-parse --show-toplevel");
}

function repoName(): string {
  const top = gitTopLevel();
  return path.basename(top);
}

function getBranches(): string[] {
  const out = run("git for-each-ref --format='%(refname:short)' refs/heads/");
  return out.split(/\r?\n/).map(s => s.trim()).filter(Boolean).map(s => s.replace(/^'|'$/g, ""));
}

function getTags(): string[] {
  const out = run("git tag --list");
  return out.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
}

function commitsOfBranch(branch: string, n: number): string[] {
  const out = run(`git rev-list --max-count=${n} --first-parent ${escapeShellArg(branch)}`);
  return out.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
}

function commitInfo(sha: string) {
  const fmt = "%H%n%an%n%ae%n%ad%n%B";
  const out = run(`git show -s --format=${escapeShellArg(fmt)} ${sha}`);
  const parts = out.split(/\r?\n/);
  const commit = {
    sha: parts[0],
    author_name: parts[1],
    author_email: parts[2],
    date: parts[3],
    message: parts.slice(4).join("\n").trim()
  };
  const parents = run(`git rev-list --parents -n 1 ${sha}`).split(/\s+/).slice(1);
  (commit as any).parents = parents;
  return commit;
}

function commitPatch(sha: string) {
  return run(`git show --no-color --pretty=fuller --patch ${sha}`);
}

function treeFiles(sha: string) {
  const out = run(`git ls-tree -r --name-only ${sha}`);
  return out.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
}

function blobSize(sha: string, filePath: string): number | null {
  try {
    const out = run(`git cat-file -s ${sha}:${escapeShellArg(filePath)}`);
    return parseInt(out, 10);
  } catch {
    return null;
  }
}

function blobContent(sha: string, filePath: string, maxBytes: number): string | null {
  try {
    const size = blobSize(sha, filePath);
    if (size === null || size > maxBytes) return null;
    return run(`git show ${sha}:${escapeShellArg(filePath)}`);
  } catch {
    return null;
  }
}

function escapeShellArg(s: string) {
  if (/^[a-zA-Z0-9_@%+=:,./-]+$/.test(s)) return s;
  return `'${s.replace(/'/g, "'\\''")}'`;
}

function scanForSecrets(text: string) {
  const patterns: [string, RegExp][] = [
    ["AWS Access Key ID", /AKIA[0-9A-Z]{16}/],
    ["Private RSA", /-----BEGIN( RSA)? PRIVATE KEY-----/],
    ["Slack token", /xox[baprs]-[0-9A-Za-z]{10,}/],
    ["JWT-looking", /eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}/],
    ["Generic password-like", /(password|passwd|pwd)[\s:=]{1,6}['"]?[^'"\s]{6,}/i]
  ];
  const hits: string[] = [];
  for (const [name, re] of patterns) {
    if (re.test(text)) hits.push(name);
  }
  return hits;
}

async function main() {
  const program = new Command();
  program
    .name("gllm")
    .version(pkg.version)
    .description("Export git repository into Markdown suitable for LLMs")
    .option("-o, --out <dir>", "output folder", "gllm_export")
    .option("-b, --branches <branches>", "'all' or comma-separated branch names", "all")
    .option("-c, --commits-per-branch <n>", "commits per branch", (v) => parseInt(v, 10), 30)
    .option("--max-file-size <bytes>", "max file size to include (bytes)", (v) => parseInt(v, 10), 200000)
    .option("--include-files", "include file snapshots", false)
    .option("--exclude <paths>", "comma-separated paths to exclude", "")
    .option("--no-secret-scan", "disable quick secret scanning (not recommended)")
    .parse(process.argv);

  const opts = program.opts() as Options;
  const outdir = path.resolve(opts.out);
  fs.mkdirSync(outdir, { recursive: true });

  const top = gitTopLevel();
  const repo = repoName();
  console.log(`Repo: ${repo}`);
  console.log(`Top-level: ${top}`);
  console.log(`Writing export to: ${outdir}\n`);

  writeFile(path.join(outdir, "README.md"), `# Repo export for LLM\n\nRepo: ${repo}\n\nGenerated by gllm\n`);

  let branches: string[] = [];
  if (opts.branches === "all") {
    branches = getBranches();
  } else {
    branches = opts.branches.split(",").map(s => s.trim()).filter(Boolean);
  }

  writeFile(path.join(outdir, "index.md"), "# Index\n\nBranches:\n" + branches.map(b => `- ${b}`).join("\n"));

  const tags = getTags();
  writeFile(path.join(outdir, "tags.md"), "# Tags\n\n" + (tags.length ? tags.map(t => `- ${t}`).join("\n") : "No tags"));

  const excludeArr = opts.exclude ? opts.exclude.split(",").map(s => s.trim()).filter(Boolean) : [];

  for (const br of branches) {
    const safeBranch = safeName(br);
    console.log(`Exporting branch: ${br}`);
    const branchCommits = commitsOfBranch(br, opts.commitsPerBranch);
    const branchMdLines: string[] = [];
    branchMdLines.push(`# Branch ${br}\n`);
    branchMdLines.push(`Commits (last ${branchCommits.length}):\n`);
    for (const sha of branchCommits) {
      const info = commitInfo(sha);
      branchMdLines.push(`- ${info.sha}: ${info.message.split(/\r?\n/)[0] || ""} (${info.author_name})`);
    }
    writeFile(path.join(outdir, "branch", `${safeBranch}.md`), branchMdLines.join("\n"));

    for (const sha of branchCommits) {
      const info = commitInfo(sha);
      const patch = commitPatch(sha);
      const files = treeFiles(sha).filter(f => !excludeArr.some(e => f.startsWith(e)));

      const metaLines: string[] = [];
      metaLines.push("---");
      metaLines.push(`repo: ${repo}`);
      metaLines.push(`branch: ${br}`);
      metaLines.push(`commit: ${info.sha}`);
      metaLines.push(`author: ${info.author_name} <${info.author_email}>`);
      metaLines.push(`date: ${info.date}`);
      if ((info as any).parents && (info as any).parents.length) {
        metaLines.push("parents:");
        for (const p of (info as any).parents) metaLines.push(`  - ${p}`);
      }
      metaLines.push(`files_changed: ${files.length}`);
      metaLines.push(`summary: ${info.message.split(/\r?\n/)[0] || ""}`);
      metaLines.push("---\n");

      metaLines.push(`# Commit ${info.sha}\n`);
      metaLines.push(`**Author:** ${info.author_name}  \n**Date:** ${info.date}\n\n## Message\n${info.message}\n\n---\n`);
      metaLines.push("## Patch (diff)\n");
      metaLines.push("```diff\n");
      metaLines.push(patch);
      metaLines.push("\n```\n");

      metaLines.push("## Files snapshot (links)\n");
      for (const f of files) {
        const fnameSafe = safeName(f);
        const link = `files/${fnameSafe}@${sha}.md`;
        metaLines.push(`- \`${f}\` — snapshot: \`${link}\``);

        if (opts.includeFiles) {
          const blob = blobContent(sha, f, opts.maxFileSize);
          if (blob !== null) {
            const lang = guessLangByExt(f);
            const fileMd = [`# Snapshot of \`${f}\` @ ${sha}`, `Commit: ${sha}`, "```" + (lang || ""), blob, "```"].join("\n");
            writeFile(path.join(outdir, link), fileMd);
            if (opts.secretScan) {
              const hits = scanForSecrets(blob);
              if (hits.length) {
                writeFile(path.join(outdir, `alerts/${fnameSafe}@${sha}.secret.txt`), `Potential secrets detected in ${f} @ ${sha}:\n` + hits.join("\n"));
                console.warn(`⚠️ Potential secrets detected in ${f} @ ${sha}: ${hits.join(", ")} — alert file written.`);
              }
            }
          } else {
            const note = `# Snapshot skipped (too large or binary) \`${f}\` @ ${sha}\nSize exceeded ${opts.maxFileSize} bytes or can't read blob.`;
            writeFile(path.join(outdir, link), note);
          }
        }
      }

      writeFile(path.join(outdir, "commits", `${info.sha}.md`), metaLines.join("\n"));
    }
  }

  console.log(`\nExport finished: ${outdir}`);
  console.log(`Recommendation: first feed index.md + branch/<branch>.md + last N commits. Then request diffs/files for specific commits.`);
}

main().catch(err => {
  console.error("Fatal:", err.message || err);
  process.exit(1);
});