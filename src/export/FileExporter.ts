import * as fs from "fs";
import * as path from "path";

export class FileExporter {
  private readonly outputDir: string;

  constructor(outputDir: string) {
    this.outputDir = outputDir;
    this.ensureDirectoryExists(outputDir);
  }

  private ensureDirectoryExists(dir: string): void {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }

  async writeFile(relativePath: string, content: string): Promise<void> {
    const fullPath = path.join(this.outputDir, relativePath);
    const dir = path.dirname(fullPath);
    
    this.ensureDirectoryExists(dir);
    fs.writeFileSync(fullPath, content, { encoding: "utf-8" });
  }

  async writeBranchSummary(branch: string, content: string): Promise<void> {
    await this.writeFile(path.join("branch", `${branch}.md`), content);
  }

  async writeCommit(sha: string, content: string): Promise<void> {
    await this.writeFile(path.join("commits", `${sha}.md`), content);
  }

  async writeAlert(relativePath: string, content: string): Promise<void> {
    await this.writeFile(relativePath, content);
  }

  async writeIndex(branches: string[]): Promise<void> {
    const content = "# Index\n\nBranches:\n" + branches.map(b => `- ${b}`).join("\n");
    await this.writeFile("index.md", content);
  }

  async writeTags(tags: string[]): Promise<void> {
    const content = "# Tags\n\n" + (tags.length ? tags.map(t => `- ${t}`).join("\n") : "No tags");
    await this.writeFile("tags.md", content);
  }

  async writeReadme(repoName: string): Promise<void> {
    const content = `# Repo export for LLM\n\nRepo: ${repoName}\n\nGenerated by gllm\n`;
    await this.writeFile("README.md", content);
  }
}
